"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[8118],{80400:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var o=n(74848),i=n(28453);const r={title:"Player Positions",slug:"player-positions",hidden:!1,createdAt:"2021-01-22T00:32:00.432Z",updatedAt:"2023-03-28T19:07:26.827Z"},s=void 0,a={id:"worlds/udon/players/player-positions",title:"Player Positions",description:"The player's position, rotation, and velocity can be accessed and changed with Udon. All of the following nodes require VRCPlayerAPI as an input.",source:"@site/docs/worlds/udon/players/player-positions.md",sourceDirName:"worlds/udon/players",slug:"/worlds/udon/players/player-positions",permalink:"/creator-docs-i18n/worlds/udon/players/player-positions",draft:!1,unlisted:!1,editUrl:"https://github.com/FairplexVR/creator-docs/edit/main/Docs/docs/worlds/udon/players/player-positions.md",tags:[],version:"current",lastUpdatedBy:"github-actions[bot]",lastUpdatedAt:1706320042,formattedLastUpdatedAt:"Jan 27, 2024",frontMatter:{title:"Player Positions",slug:"player-positions",hidden:!1,createdAt:"2021-01-22T00:32:00.432Z",updatedAt:"2023-03-28T19:07:26.827Z"},sidebar:"tutorialSidebar",previous:{title:"Player Forces",permalink:"/creator-docs-i18n/worlds/udon/players/player-forces"},next:{title:"Using Build & Test",permalink:"/creator-docs-i18n/worlds/udon/using-build-test"}},l={},d=[{value:"GetPosition",id:"getposition",level:3},{value:"GetRotation",id:"getrotation",level:3},{value:"GetBonePosition",id:"getboneposition",level:3},{value:"GetBoneRotation",id:"getbonerotation",level:3},{value:"GetTrackingData",id:"gettrackingdata",level:3},{value:"GetVelocity",id:"getvelocity",level:3},{value:"SetVelocity",id:"setvelocity",level:3},{value:"IsPlayerGrounded",id:"isplayergrounded",level:3},{value:"TeleportTo",id:"teleportto",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The player's position, rotation, and velocity can be accessed and changed with Udon. All of the following nodes require ",(0,o.jsx)(t.code,{children:"VRCPlayerAPI"})," as an input."]}),"\n",(0,o.jsxs)(t.p,{children:["For nodes that deal with forces relating to Players, see ",(0,o.jsx)(t.a,{href:"/worlds/udon/players/player-forces",children:"Player Forces"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"getposition",children:"GetPosition"}),"\n",(0,o.jsx)(t.p,{children:"Gets the position of the Player."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Vector3"}),": The player's position in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"getrotation",children:"GetRotation"}),"\n",(0,o.jsx)(t.p,{children:"Gets the rotation of the Player."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Input"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Quaternion"}),": The player's rotation in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"getboneposition",children:"GetBonePosition"}),"\n",(0,o.jsx)(t.p,{children:"Gets the position of the specified Bone in the Player's Avatar, or Vector3.Zero (0,0,0) if the bone does not exist. Note that Avatars may not have all the same bones in the places you expect, so be careful making assumptions about attributes like a player's height, pose etc based on the position of bones."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Input"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"HumanBodyBones"}),": The bone to check."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Vector3"}),": The bone position in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"getbonerotation",children:"GetBoneRotation"}),"\n",(0,o.jsx)(t.p,{children:"Gets the rotation of the specified Bone in the Player's Avatar, or Quaternion.Identity (0,0,0,1) if the bone does not exist. Note that Avatars may not have all the same bones in the places you expect, so be careful making assumptions about attributes like a player's height, pose etc based on the rotation of bones."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Quaternion"}),": The bone rotation in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"gettrackingdata",children:"GetTrackingData"}),"\n",(0,o.jsx)(t.p,{children:"Gets a struct called TrackingData, which contains separate Position and Rotation data. This is the suggested way to get position and rotation data for a Player's head and hands. This returns data from the TrackingManager for a Local Player (ie the data coming from their headset / trackers) and from the RightHand, LeftHand and Head bones for a Remote Player. Origin returns the center of the local VR user's playspace, while returning the player's position for local Desktop users and all remote users. AvatarRoot returns data for the root transform of the avatar (the same transform that the player capsule is attached to). For users in Fully-Body Tracking, AvatarRoot will not rotate with the head facing direction. If you need data reflecting the general forward facing direction of a Player, consider using GetRotation instead."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Input"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"TrackingDataType"}),": The tracking data to check."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"TrackingData"}),": The player's tracking data of the specified type."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"getvelocity",children:"GetVelocity"}),"\n",(0,o.jsx)(t.p,{children:"Get the speed and direction of the player's movement."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Output"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Vector3 velocity"}),": The player's velocity in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"setvelocity",children:"SetVelocity"}),"\n",(0,o.jsx)(t.p,{children:"Set the speed and direction of the player's movement. If SetVelocity is called on the local player, their 'IsGrounded' property is set to false since they are not in direct control of their movements while this is happening."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Input"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Vector3"}),": The player's velocity in world space."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"isplayergrounded",children:"IsPlayerGrounded"}),"\n",(0,o.jsx)(t.p,{children:"Get whether the player is touching the ground, which enables Jump."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Ouput"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"bool IsPlayerGrounded"}),": Whether the player is grounded."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"teleportto",children:"TeleportTo"}),"\n",(0,o.jsx)(t.admonition,{title:"Teleporting other players",type:"note",children:(0,o.jsxs)(t.p,{children:["TeleportTo only works with the ",(0,o.jsx)(t.a,{href:"/worlds/udon/players/getting-players/#networkingget-localplayer",children:"local player"}),". You can use ",(0,o.jsx)(t.a,{href:"/worlds/udon/networking/",children:"networking"})," to cause other players to teleport themselves."]})}),"\n",(0,o.jsx)(t.p,{children:"Send a player to a new spot and specified rotation, unless a Station does not allow it."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Inputs"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Vector3 teleportPos"}),": The target position in world space."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Quaternion teleportRot"}),": The target rotation in world space."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"SceneDescriptorSpawnOrientation TeleportOrientation"})," (optional): How to align players with the destination position and rotation."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"bool lerpOnRemote"})," (optional): Whether to interpolate the player's movement. If true, the teleportation is instantaneous and incurs and additional network bandwidth cost. If false, the teleportation is treated as normal player movement."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(96540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);