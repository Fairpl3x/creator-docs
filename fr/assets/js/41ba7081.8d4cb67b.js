"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[4049],{35355:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(74848),o=n(28453);const r={title:"Byte and Bit Operations",slug:"byte-and-bit-operations",hidden:!1,sidebar_position:10,createdAt:"2024-02-26T18:00:00.000Z",updatedAt:"2024-02-26T18:00:00.000Z"},i="Byte and Bit Operations",s={id:"worlds/udon/data-containers/byte-and-bit-operations",title:"Byte and Bit Operations",description:"This page describes lower level concepts of working with binary data and is intended for advanced creators.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/worlds/udon/data-containers/byte-and-bit-operations.md",sourceDirName:"worlds/udon/data-containers",slug:"/worlds/udon/data-containers/byte-and-bit-operations",permalink:"/creator-docs-i18n/fr/worlds/udon/data-containers/byte-and-bit-operations",draft:!1,unlisted:!1,editUrl:"https://github.com/FairplexVR/creator-docs/edit/main/Docs/i18n/fr/docusaurus-plugin-content-docs/current/worlds/udon/data-containers/byte-and-bit-operations.md",tags:[],version:"current",lastUpdatedBy:"Fairplex",lastUpdatedAt:1713821541,formattedLastUpdatedAt:"22 avr. 2024",sidebarPosition:10,frontMatter:{title:"Byte and Bit Operations",slug:"byte-and-bit-operations",hidden:!1,sidebar_position:10,createdAt:"2024-02-26T18:00:00.000Z",updatedAt:"2024-02-26T18:00:00.000Z"},sidebar:"tutorialSidebar",previous:{title:"Data Containers",permalink:"/creator-docs-i18n/fr/worlds/udon/data-containers/"},next:{title:"Data Dictionaries",permalink:"/creator-docs-i18n/fr/worlds/udon/data-containers/data-dictionaries"}},l={},u=[{value:"Example Code",id:"example-code",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"byte-and-bit-operations",children:"Byte and Bit Operations"}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsx)(t.p,{children:"This page describes lower level concepts of working with binary data and is intended for advanced creators."})}),"\n",(0,a.jsxs)(t.p,{children:["You can use the ",(0,a.jsx)(t.code,{children:"Bitcast"}),' method on DataTokens to do value-preserving type changes ("unsafe casts") on primitive data types in Udon.']}),"\n",(0,a.jsxs)(t.p,{children:["Some standard C# classes for operating on raw binary data are also available, including ",(0,a.jsx)(t.code,{children:"BitConverter"})," and ",(0,a.jsx)(t.code,{children:"Buffer"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"example-code",children:"Example Code"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:'title="Byte and Bit Operations Example, Basic Serializer"',children:'using System;\nusing System.Text;\nusing UdonSharp;\nusing UnityEngine;\nusing VRC.SDK3.Data;\n\npublic class BitConverterExample : UdonSharpBehaviour\n{\n    void Start()\n    {\n        //Create test data\n        int originalInt = 63;\n        double originalDouble = 734531.433d;\n        string originalString = "Test string";\n        float[] originalFloatArray = new float[] { 543, 12.6f, 63.1231f };\n\n        //Serialize and then deserialize\n        byte[] serialized = Serialize(originalInt, originalDouble, originalString, originalFloatArray);\n        Deserialize(serialized, out int newInt, out double newDouble, out string newString, out float[] newFloatArray); \n        \n        //Print the results to see if everything matches\n        Debug.Log($"{originalInt} - {newInt}");\n        Debug.Log($"{originalDouble} - {newDouble}");\n        Debug.Log($"{originalString} - {newString}");\n        Debug.Log($"{originalFloatArray.Length} - {newFloatArray.Length}");\n        for (int i = 0; i < originalFloatArray.Length && i < newFloatArray.Length; i++)\n        {\n            Debug.Log($"{originalFloatArray[i]} - {newFloatArray[i]}");\n        }\n\n        //For individual values we can also use DataToken Bitcasting to get bit access\n        double doubleValue = 123.456d;\n        DataToken doubleToken = new DataToken(doubleValue);\n        //We used ulong because it has the same size as a double (8 bytes)\n        DataToken ulongToken = doubleToken.Bitcast(TokenType.ULong);\n        DataToken resultDoubleToken = ulongToken.Bitcast(TokenType.Double);\n        Debug.Log($"{doubleToken} - 0x{ulongToken:02X} - {resultDoubleToken}");\n    }\n\n    /// <summary>\n    /// An example function which serializes a pre-determined set of data into a byte array\n    /// </summary>\n    /// <param name="intValue">Integer which will be encoded into the output</param>\n    /// <param name="doubleValue">Double which will be encoded into the output</param>\n    /// <param name="stringValue">String which will be encoded into the output</param>\n    /// <param name="floatArrayValues">Float array which will be encoded into the output</param>\n    /// <returns></returns>\n    byte[] Serialize(int intValue, double doubleValue, string stringValue, float[] floatArrayValues)\n    {\n        int size = 0;\n        byte[] intBytes = BitConverter.GetBytes(intValue); //Convert int to bytes\n        size += intBytes.Length;\n        \n        byte[] doubleBytes = BitConverter.GetBytes(doubleValue); //Convert int to bytes\n        size += doubleBytes.Length;\n        \n        byte[] stringBytes = Encoding.UTF8.GetBytes(stringValue); //Convert string to bytes\n        size += stringBytes.Length;\n        Debug.Log($"String byte length {stringBytes.Length}");\n        \n        byte[] stringLengthBytes = BitConverter.GetBytes(stringBytes.Length); //Convert string length to bytes\n        size += stringLengthBytes.Length;\n        \n        byte[] floatArrayLengthBytes = BitConverter.GetBytes(Buffer.ByteLength(floatArrayValues));\n        size += floatArrayLengthBytes.Length;\n        \n        //It is not necessary to convert the float array into a byte array because we can BlockCopy it directly\n        size += Buffer.ByteLength(floatArrayValues);\n\n        byte[] output = new byte[size]; //Allocate an array of the correct size that should fit all of our items\n        int offset = 0;\n\n        Buffer.BlockCopy(intBytes, 0, output, offset, intBytes.Length); //Write int - this should take up 4 bytes\n        offset += intBytes.Length; //Increment offset so the next item can write to the correct location\n        \n        Buffer.BlockCopy(doubleBytes, 0, output, offset, doubleBytes.Length); //Write double - this should take up 8 bytes\n        offset += doubleBytes.Length;\n        \n        Buffer.BlockCopy(stringLengthBytes, 0, output, offset, stringLengthBytes.Length); //Write the length of the string so the decoder knows how much to decode - this should take up 4 bytes\n        offset += stringLengthBytes.Length;\n\n        Buffer.BlockCopy(stringBytes, 0, output, offset, stringBytes.Length); //Write string - this is variable, which is why we need to encode the length of the string above\n        offset += stringBytes.Length;\n\n        Buffer.BlockCopy(floatArrayLengthBytes, 0, output, offset, floatArrayLengthBytes.Length); //Write the length of the float array so the decoder knows how much to decode - this should take up 4 bytes\n        offset += floatArrayLengthBytes.Length;\n        \n        Buffer.BlockCopy(floatArrayValues, 0, output, offset, Buffer.ByteLength(floatArrayValues)); //Write float array - this can be done directly without a byte array conversion because it\'s already an Array\n        offset += Buffer.ByteLength(floatArrayValues);\n        \n        Debug.Log($"Encoded data in {output.Length} bytes");\n        return output;\n    }\n\n    /// <summary>\n    /// An example function which deserializes a pre-determined set of data described in the Serialize function above\n    /// </summary>\n    /// <param name="input">Input bytes - must be formatted in the expected manner by the Serialize function above</param>\n    /// <param name="intValue">Output int value deserialized from the data inside the input</param>\n    /// <param name="doubleValue">Output double value deserialized from the data inside the input</param>\n    /// <param name="stringValue">Output string value deserialized from the data inside the input</param>\n    /// <param name="floatArrayValues">Output float array value deserialized from the data inside the input</param>\n    /// <returns></returns>\n    bool Deserialize(byte[] input, out int intValue, out double doubleValue, out string stringValue, out float[] floatArrayValues)\n    {\n        int offset = 0;\n        \n        intValue = BitConverter.ToInt32(input, offset);\n        offset += 4; //Increment the offset so the next item reads from the correct location. Ints should be 4 bytes long\n        \n        doubleValue = BitConverter.ToDouble(input, offset);\n        offset += 8; //Doubles should be 8 bytes long\n        \n        int stringLength = BitConverter.ToInt32(input, offset);\n        offset += 4; //String length is an int, which should be 4 bytes long\n        \n        Debug.Log($"Decoding string length {stringLength} at offset {offset} for buffer length {input.Length}");\n        stringValue = Encoding.UTF8.GetString(input, offset, stringLength);\n        offset += stringLength; //Strings are variable length\n\n        int floatArrayByteLength = BitConverter.ToInt32(input, offset);\n        offset += 4; //Float array length is an int, which should be 4 bytes long\n        \n        floatArrayValues = new float[floatArrayByteLength / 4]; //Create a new float array of the correct size to receive the data\n        Buffer.BlockCopy(input, offset, floatArrayValues, 0, floatArrayByteLength); //Copy the data from the input into the float array\n        \n        return true;\n    }\n}\n'})})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(96540);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);